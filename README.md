# Google Cloud Platform - Task & Workflow Orchestration Demos

This repository contains comprehensive demos for 4 GCP services that handle task scheduling, event processing, and workflow orchestration.

## Table of Contents
- [Service Comparisons](#service-comparisons)
- [Detailed Differences](#detailed-differences)
- [Common Use Cases](#common-use-cases)
- [Running the Demos](#running-the-demos)
- [Prerequisites](#prerequisites)

---

## Service Comparisons

### Quick Reference Table

| Feature | Cloud Scheduler | Cloud Tasks | Eventarc | Workflows |
|---------|----------------|-------------|----------|-----------|
| **Primary Purpose** | Time-based scheduling | Async task queuing | Event routing | Service orchestration |
| **Trigger Type** | Cron schedule | Programmatic API | Events (90+ sources) | Manual/scheduled/event |
| **Execution Pattern** | Recurring or one-time | On-demand, queued | Event-driven | Multi-step sequences |
| **Rate Control** | Schedule-based | Queue-level throttling | None (event-based) | Workflow-level |
| **Retries** | Limited (3 attempts) | Configurable with backoff | Delivery retries | Built-in with backoff |
| **Ordering** | N/A | FIFO optional | Best-effort | Sequential in workflow |
| **State Management** | None | Task-level | None | Full workflow state |
| **Cost Model** | Per job | Per task execution | Per event delivery | Per workflow step |

---

## Detailed Differences

### üïê Cloud Scheduler
**What it is**: A fully managed cron job service for GCP.

**How it works**:
- Define a schedule using cron syntax (e.g., `0 */6 * * *` for every 6 hours)
- Configure a target (HTTP endpoint, Pub/Sub topic, or App Engine app)
- Scheduler invokes the target at specified times
- Limited retry mechanism (3 attempts with exponential backoff)

**Architecture**:
```
Cron Schedule ‚Üí Cloud Scheduler ‚Üí Target (HTTP/Pub/Sub/App Engine)
```

**Key Characteristics**:
- **No state management**: Each execution is independent
- **Time-driven**: Runs based on calendar/clock, not events
- **Simple**: Best for straightforward periodic tasks
- **Limited retries**: Not ideal for critical tasks requiring guaranteed delivery

---

### üìã Cloud Tasks
**What it is**: A fully managed task queue service for asynchronous workload distribution.

**How it works**:
- Create a task queue with rate limits and retry configuration
- Programmatically add tasks to the queue (via API or SDK)
- Tasks are delivered to HTTP endpoints (Cloud Functions, Cloud Run, etc.)
- Advanced retry logic with configurable backoff
- Rate limiting prevents overwhelming your services

**Architecture**:
```
Application ‚Üí Cloud Tasks Queue ‚Üí Worker (HTTP endpoint)
                ‚Üì
         Rate Limiting
         Retry Logic
         Deduplication
```

**Key Characteristics**:
- **Asynchronous**: Decouples task creation from execution
- **Rate control**: Prevents overwhelming downstream services
- **Reliable**: Guaranteed delivery with configurable retries
- **Task-level configuration**: Each task can have custom retry/schedule settings
- **Deduplication**: Prevents duplicate task execution

---

### üéØ Eventarc
**What it is**: An event routing platform that delivers events from 90+ Google Cloud sources.

**How it works**:
- Events are generated by GCP services (e.g., Cloud Storage, BigQuery, Pub/Sub)
- Eventarc routes these events to targets (Cloud Run, Cloud Functions, Workflows)
- Uses CloudEvents standard format
- Supports custom events via Pub/Sub
- Filter events based on attributes

**Architecture**:
```
Event Sources (90+) ‚Üí Eventarc (Routing/Filtering) ‚Üí Targets
    ‚Üì
Cloud Storage
BigQuery
Pub/Sub         ‚Üí Trigger Filters ‚Üí Cloud Run
Firestore                         ‚Üí Cloud Functions
Cloud Build                       ‚Üí Workflows
etc.
```

**Key Characteristics**:
- **Event-driven**: Reacts to state changes in GCP services
- **Decoupled**: Producers don't know about consumers
- **Scalable**: Automatically handles event volume
- **Standardized**: Uses CloudEvents format
- **Flexible routing**: Multiple triggers can listen to same event source

---

### üîÑ Workflows
**What it is**: A serverless orchestration platform for defining multi-step processes.

**How it works**:
- Define workflows in YAML or JSON
- Chain together GCP services, APIs, and connectors
- Built-in error handling, retries, and conditional logic
- Supports parallel execution, loops, and subworkflows
- Maintains execution state throughout the workflow

**Architecture**:
```
Trigger ‚Üí Workflow Engine ‚Üí Step 1 (API call)
                          ‚Üí Step 2 (Conditional)
                          ‚Üí Step 3a | Step 3b (Parallel)
                          ‚Üí Step 4 (Aggregation)
                          ‚Üí Final Result
```

**Key Characteristics**:
- **Orchestration**: Coordinates multiple services in sequence or parallel
- **Stateful**: Maintains workflow state and variables
- **Complex logic**: Supports conditionals, loops, try-catch
- **Visual**: Can be viewed in Cloud Console as flowchart
- **Built-in integrations**: 100+ connectors to GCP and external services
- **Long-running**: Can execute for up to 1 year

---

## Common Use Cases

### üïê Cloud Scheduler Use Cases

1. **Regular Data Exports**
   - Schedule daily database backups at 2 AM
   - Export analytics data to BigQuery every hour
   - Generate monthly reports on the 1st of each month

2. **Maintenance Tasks**
   - Clean up temporary files every 6 hours
   - Refresh materialized views nightly
   - Rotate logs weekly

3. **Monitoring & Health Checks**
   - Ping services every 5 minutes to check availability
   - Run synthetic transactions hourly
   - Send daily infrastructure cost reports

4. **Batch Processing**
   - Process overnight batch jobs
   - Send scheduled email newsletters
   - Update caches at specific times

**Example**: Send a summary email every Monday at 9 AM
```bash
gcloud scheduler jobs create http weekly-summary \
  --schedule="0 9 * * 1" \
  --uri="https://myapp.com/send-summary" \
  --http-method=POST
```

---

### üìã Cloud Tasks Use Cases

1. **User Request Offloading**
   - Image/video processing after upload
   - PDF generation triggered by user action
   - Email sending without blocking API response

2. **Rate-Limited API Calls**
   - Calling third-party APIs with rate limits
   - Bulk operations that need throttling
   - Database migrations with controlled throughput

3. **Reliable Background Jobs**
   - Payment processing with retries
   - Order fulfillment workflows
   - Data synchronization between systems

4. **Fan-out Processing**
   - Send notifications to millions of users
   - Process each row from a large dataset
   - Distribute work across multiple workers

**Example**: Process uploaded image asynchronously
```python
from google.cloud import tasks_v2

client = tasks_v2.CloudTasksClient()
task = {
    'http_request': {
        'http_method': tasks_v2.HttpMethod.POST,
        'url': 'https://worker.com/resize-image',
        'headers': {'Content-Type': 'application/json'},
        'body': json.dumps({'image_id': '12345'}).encode()
    }
}
client.create_task(parent=queue_path, task=task)
```

---

### üéØ Eventarc Use Cases

1. **Storage Event Processing**
   - Trigger image processing when file uploaded to Cloud Storage
   - Start transcoding pipeline on video upload
   - Index documents when added to bucket

2. **Database Change Reactions**
   - Send notification when Firestore document created
   - Update search index on BigQuery table change
   - Sync data when Cloud SQL row modified

3. **CI/CD Integration**
   - Deploy to staging when Cloud Build completes
   - Run tests when code pushed to repository
   - Notify team when build fails

4. **Audit & Compliance**
   - Log all resource modifications
   - Alert on security policy changes
   - Track data access patterns

**Example**: Process files uploaded to Cloud Storage
```bash
gcloud eventarc triggers create storage-trigger \
  --destination-run-service=process-file \
  --destination-run-region=us-central1 \
  --event-filters="type=google.cloud.storage.object.v1.finalized" \
  --event-filters="bucket=my-upload-bucket"
```

---

### üîÑ Workflows Use Cases

1. **Multi-Service Orchestration**
   - Validate data ‚Üí Transform ‚Üí Load ‚Üí Notify (ETL pipeline)
   - Lookup user ‚Üí Check permissions ‚Üí Process request ‚Üí Update records
   - Multi-step approval workflows

2. **Error Handling & Retries**
   - Call API with automatic retry on failure
   - Fallback to alternative service if primary fails
   - Compensating transactions on errors

3. **Complex Business Logic**
   - Order processing: validate ‚Üí charge card ‚Üí update inventory ‚Üí ship
   - Insurance claim processing with multiple decision points
   - Multi-step data validation and enrichment

4. **Parallel Processing**
   - Call multiple APIs simultaneously
   - Process multiple files in parallel
   - Aggregate results from multiple sources

5. **Human-in-the-Loop**
   - Wait for approval before proceeding
   - Escalation workflows with timeouts
   - Multi-stage review processes

**Example**: Multi-step order processing
```yaml
- validate_order:
    call: http.post
    args:
      url: https://api.example.com/validate
      body: ${order}
    result: validation_result

- check_validation:
    switch:
      - condition: ${validation_result.valid == true}
        next: charge_payment
      - condition: true
        next: send_error_notification

- charge_payment:
    call: http.post
    args:
      url: https://payments.example.com/charge
      body: ${order.payment}
    result: payment_result

- update_inventory:
    call: http.post
    args:
      url: https://inventory.example.com/reduce
      body: ${order.items}
```

---

## Decision Guide: Which Service to Use?

### üïê Cloud Scheduler

**‚úÖ Use When:**

1. **Database maintenance jobs**
   - Example: Run `VACUUM` on PostgreSQL every night at 2 AM
   - Why: Scheduled maintenance needs to happen at specific times

2. **Report generation**
   - Example: Generate daily sales reports every morning at 9 AM
   - Why: Reports are needed on a predictable schedule

3. **Cache warming**
   - Example: Refresh product catalog cache every hour
   - Why: Regular intervals ensure fresh data

**‚ùå Don't Use When:**

1. **You need to react to events** ‚Üí Use **Eventarc** instead
   - Example: Process file immediately when uploaded
   - Why: Can't wait for next scheduled run; need immediate reaction

2. **You need guaranteed delivery with retries** ‚Üí Use **Cloud Tasks** instead
   - Example: Critical payment processing
   - Why: Scheduler has limited retry attempts (3 max)

3. **You need to orchestrate multiple services** ‚Üí Use **Workflows** instead
   - Example: Multi-step approval process
   - Why: Scheduler can't handle complex conditional logic

---

### üìã Cloud Tasks

**‚úÖ Use When:**

1. **Offloading user-facing operations**
   - Example: Send welcome email after user signs up (don't make user wait)
   - Why: Improves response time; user gets instant feedback

2. **Rate-limited API calls**
   - Example: Sync 10,000 records to external CRM at 100 req/sec max
   - Why: Queue automatically throttles to respect rate limits

3. **Reliable background processing**
   - Example: Process credit card charges with automatic retries
   - Why: Tasks are retried with exponential backoff until success

**‚ùå Don't Use When:**

1. **Tasks need to run on a schedule** ‚Üí Use **Cloud Scheduler** instead
   - Example: Daily backup at 3 AM
   - Why: Use cron for time-based triggers, not queuing

2. **You need to react to GCP service events** ‚Üí Use **Eventarc** instead
   - Example: Resize image when uploaded to Cloud Storage
   - Why: Direct event triggers are more efficient than polling

3. **You need complex multi-step logic** ‚Üí Use **Workflows** instead
   - Example: Order processing (validate ‚Üí charge ‚Üí ship ‚Üí notify)
   - Why: Tasks execute independently; can't coordinate steps

---

### üéØ Eventarc

**‚úÖ Use When:**

1. **File upload processing**
   - Example: Automatically generate thumbnails when images uploaded to bucket
   - Why: Events trigger immediately on upload; no polling needed

2. **Reacting to database changes**
   - Example: Send notification when high-value order created in Firestore
   - Why: Real-time reaction to data changes

3. **CI/CD automation**
   - Example: Deploy to production when Cloud Build succeeds
   - Why: Event-driven pipeline is more reliable than polling

**‚ùå Don't Use When:**

1. **You need complex orchestration** ‚Üí Use **Workflows** instead
   - Example: Multi-step ETL with conditionals and error handling
   - Why: Eventarc routes events but doesn't orchestrate workflows

2. **Tasks need to run on schedule** ‚Üí Use **Cloud Scheduler** instead
   - Example: Generate monthly invoices on the 1st of each month
   - Why: No event occurs; needs time-based trigger

3. **You need rate limiting and controlled processing** ‚Üí Use **Cloud Tasks** instead
   - Example: Process 1 million events but limit to 100/sec
   - Why: Eventarc delivers events as they occur; no rate control

---

### üîÑ Workflows

**‚úÖ Use When:**

1. **Multi-service orchestration**
   - Example: User signup (create account ‚Üí send email ‚Üí provision resources ‚Üí notify admin)
   - Why: Coordinates multiple services with error handling

2. **Complex business logic**
   - Example: Insurance claim (validate ‚Üí assess damages ‚Üí approve/deny ‚Üí settle ‚Üí notify)
   - Why: Supports conditionals, loops, and decision trees

3. **Long-running processes with retries**
   - Example: Data migration (extract ‚Üí transform ‚Üí validate ‚Üí load with checkpoints)
   - Why: Maintains state; retries failed steps without starting over

**‚ùå Don't Use When:**

1. **Tasks are simple and independent** ‚Üí Use **Cloud Tasks** instead
   - Example: Send 1000 individual emails
   - Why: Overhead of workflow for simple tasks; use queue instead

2. **You're reacting to single events** ‚Üí Use **Eventarc** instead
   - Example: Log audit trail when file deleted
   - Why: Simple event-to-action; no orchestration needed

3. **High-frequency, short-duration tasks** ‚Üí Use **Cloud Functions** or **Cloud Tasks** instead
   - Example: Process 10,000 requests/second with 10ms processing time
   - Why: Workflow step overhead makes it unsuitable for high-frequency use

---

## Real-World Scenario Examples

### Scenario 1: E-commerce Order Processing

**Wrong approach:** Use Cloud Scheduler to poll for new orders every minute
- Why wrong: Wastes resources, delays order processing

**Right approach:** 
1. **Eventarc**: Trigger when order created in Firestore
2. **Workflows**: Orchestrate validation ‚Üí inventory ‚Üí payment ‚Üí shipping
3. **Cloud Tasks**: Queue individual notification emails

---

### Scenario 2: Video Transcoding Pipeline

**Wrong approach:** Use Cloud Scheduler to check for new uploads every 5 minutes
- Why wrong: Delays processing up to 5 minutes

**Right approach:**
1. **Eventarc**: Trigger immediately on video upload to Cloud Storage
2. **Workflows**: Orchestrate transcode ‚Üí generate thumbnails ‚Üí update database
3. **Cloud Tasks**: Queue notification emails (rate-limited)

---

### Scenario 3: Monthly Report Generation

**Wrong approach:** Use Eventarc waiting for some event to trigger reports
- Why wrong: No event occurs; needs time-based trigger

**Right approach:**
1. **Cloud Scheduler**: Trigger on 1st of month at 2 AM
2. **Workflows** (if needed): Orchestrate data collection ‚Üí aggregation ‚Üí formatting ‚Üí distribution
3. **Cloud Tasks** (alternative): Create individual report generation tasks if simple

---

### Scenario 4: Customer Data Sync

**Requirement:** Sync customer data to 3rd-party CRM (max 50 req/sec)

**Wrong approach:** Use Workflows to make API calls in sequence
- Why wrong: Too slow; workflows add overhead for simple task

**Right approach:**
1. **Eventarc**: Detect customer updates in Firestore
2. **Cloud Tasks**: Queue sync tasks with rate limit of 50/sec
3. Optionally trigger from **Cloud Scheduler** for periodic full syncs

---

## Combining Services

These services often work together:

1. **Scheduler + Tasks**: Schedule a job that creates many tasks
   ```
   Cloud Scheduler (daily at 2am) ‚Üí Creates 1000 tasks in Cloud Tasks ‚Üí Workers process
   ```

2. **Eventarc + Workflows**: React to event by starting workflow
   ```
   File uploaded to Storage ‚Üí Eventarc ‚Üí Workflow (validate‚Üíprocess‚Üístore‚Üínotify)
   ```

3. **Tasks + Workflows**: Queue tasks that execute workflows
   ```
   Application ‚Üí Cloud Tasks ‚Üí Workflow execution
   ```

4. **Scheduler + Workflows**: Schedule workflow execution
   ```
   Cloud Scheduler (weekly) ‚Üí Workflow (complex multi-step process)
   ```

---

## Running the Demos

Each demo directory contains:
- `setup.sh`: Creates necessary GCP resources
- `trigger.sh`: Demonstrates the service in action
- `cleanup.sh`: Removes all created resources
- `README.md`: Specific instructions for that demo

Navigate to each demo directory and follow its README.

---

## Prerequisites

Before running the demos, ensure you have:

1. **GCP Project with billing enabled**
2. **gcloud CLI installed and authenticated**
   ```bash
   gcloud auth login
   gcloud config set project YOUR_PROJECT_ID
   ```

3. **Required APIs enabled**
   ```bash
   # Enable all required APIs
   gcloud services enable \
     cloudscheduler.googleapis.com \
     cloudtasks.googleapis.com \
     eventarc.googleapis.com \
     workflows.googleapis.com \
     cloudfunctions.googleapis.com \
     cloudbuild.googleapis.com \
     run.googleapis.com \
     storage.googleapis.com
   ```

4. **Set environment variables**
   ```bash
   export PROJECT_ID=$(gcloud config get-value project)
   export REGION=us-central1
   ```

---

## Demos

1. [**Cloud Scheduler Demo**](./cloud-scheduler-demo/) - Schedule periodic tasks
2. [**Cloud Tasks Demo**](./cloud-tasks-demo/) - Queue asynchronous tasks
3. [**Eventarc Demo**](./eventarc-demo/) - React to Cloud Storage events
4. [**Workflows Demo**](./workflows-demo/) - Orchestrate multi-step processes

---

## Configuration Limits & Quotas

Understanding the limits of each service helps you design systems that scale properly.

üìö **Official Quota Documentation:**
- [Cloud Scheduler Quotas](https://cloud.google.com/scheduler/quotas)
- [Cloud Tasks Quotas](https://cloud.google.com/tasks/docs/quotas)
- [Eventarc Quotas](https://cloud.google.com/eventarc/quotas)
- [Workflows Quotas](https://cloud.google.com/workflows/quotas)

### üïê Cloud Scheduler Limits

üìñ [Full quota documentation](https://cloud.google.com/scheduler/quotas)

| Limit | Value |
|-------|-------|
| **Maximum jobs per project** | 100,000 per region |
| **Maximum job name length** | 500 characters |
| **Maximum schedule frequency** | Once per minute |
| **Request timeout** | 30 minutes (HTTP), 10 minutes (Pub/Sub) |
| **Maximum payload size** | 100 KB |
| **Maximum retry attempts** | 3 attempts |
| **Maximum backoff duration** | 3600 seconds (1 hour) |
| **Maximum execution window** | 2 hours after scheduled time |
| **Jobs that can run simultaneously** | Based on target service capacity |

**Cron Expression Limits:**
- Minimum interval: `* * * * *` (every minute)
- Maximum specificity: Minute-level (no seconds)

---

### üìã Cloud Tasks Limits

| Limit | Value |
|-------|-------|
| **Maximum queues per project** | 1,000 per location |
| **Maximum tasks per queue** | 1,000,000 active or pending |
| **Maximum queue name length** | 100 characters |
| **Maximum task name length** | 500 characters |
| **Maximum payload size** | 100 KB (HTTP), 1 MB (App Engine) |
| **Maximum task age** | 31 days |
| **Maximum dispatch rate** | 500 tasks/second per queue (configurable) |
| **Maximum concurrent tasks** | 1,000 tasks per queue (configurable) |
| **Maximum retry attempts** | Unlimited (configurable) |
| **Maximum retry duration** | Unlimited (configurable) |
| **Minimum backoff** | 0.1 seconds |
| **Maximum backoff** | 3600 seconds (1 hour) |
| **Task creation rate** | 500 tasks/second per queue |
| **Maximum schedule delay** | 30 days in the future |

**Rate Limiting Options:**
- `max-dispatches-per-second`: 1 to 500
- `max-concurrent-dispatches`: 1 to 1,000
- `max-burst-size`: Calculated automatically

**Retry Configuration:**
- `max-attempts`: 0 to unlimited
- `max-retry-duration`: 0 to unlimited
- `min-backoff`: 0.1s to 3600s
- `max-backoff`: 0.1s to 3600s
- `max-doublings`: 0 to 16

---

### üéØ Eventarc Limits

| Limit | Value |
|-------|-------|
| **Maximum triggers per location** | 200 per Google Cloud project |
| **Maximum event size** | 512 KB (CloudEvents format) |
| **Event delivery timeout** | 10 minutes |
| **Maximum event filters per trigger** | 10 filters |
| **Event retention** | Up to 7 days (retry period) |
| **Maximum retry attempts** | Based on retry policy (up to 7 days) |
| **Trigger name length** | 63 characters maximum |
| **Maximum concurrent events** | Based on target service capacity |
| **Event ordering** | Best-effort (at-least-once delivery) |

**Delivery Guarantees:**
- At-least-once delivery
- No ordering guarantees
- Automatic retries with exponential backoff
- Dead letter topic support

**Event Filter Limits:**
- Maximum 10 attribute filters per trigger
- Pattern matching support for path filters
- Case-sensitive string matching

---

### üîÑ Workflows Limits

| Limit | Value |
|-------|-------|
| **Maximum workflows per project** | 1,000 per region |
| **Maximum workflow definition size** | 1 MB (YAML or JSON) |
| **Maximum workflow name length** | 63 characters |
| **Maximum execution duration** | 1 year (configurable timeout) |
| **Maximum concurrent executions** | 10,000 per workflow |
| **Maximum steps per execution** | No hard limit (charged per step) |
| **Maximum step duration** | 120 seconds per HTTP call |
| **Maximum subworkflow depth** | 10 levels |
| **Maximum parallel branches** | 100,000 branches |
| **Maximum variables per execution** | No hard limit (limited by memory) |
| **Maximum variable size** | 256 KB per variable |
| **Maximum input/output size** | 256 KB |
| **Execution history retention** | 30 days |
| **Maximum execution creation rate** | 1,000 executions/second per workflow |

**Step Limits:**
- HTTP call timeout: 1,800 seconds (30 minutes)
- Sleep duration: 1 year maximum
- Retry attempts: Unlimited (configurable)
- Backoff multiplier: 1.0 to 10.0
- Maximum backoff: 1 year

**Built-in Connectors:**
- 100+ pre-built connectors
- Custom HTTP calls supported
- Authentication supported (OAuth, API keys, service accounts)

---

## Quota Increases

All services support quota increase requests:

1. **Request via Cloud Console:**
   - Navigate to: IAM & Admin ‚Üí Quotas
   - Filter by service name
   - Select quota to increase
   - Click "EDIT QUOTAS"

2. **Typical Approval Time:** 2-5 business days

3. **Common Increase Requests:**
   - Cloud Scheduler: Jobs per region
   - Cloud Tasks: Dispatch rate, concurrent tasks
   - Eventarc: Triggers per location
   - Workflows: Concurrent executions

---

## Performance Considerations

### Cloud Scheduler
- ‚ö° **Latency**: Typically executes within 1 second of scheduled time
- üìä **Accuracy**: ¬±1 second for cron schedules
- üîÑ **Reliability**: 99.9% execution success rate (when target is available)

### Cloud Tasks
- ‚ö° **Latency**: <1 second from task creation to dispatch (when queue not rate-limited)
- üìä **Throughput**: Up to 500 tasks/second per queue
- üîÑ **Reliability**: At-least-once delivery guarantee

### Eventarc
- ‚ö° **Latency**: Typically <1 second from event to delivery
- üìä **Scalability**: Automatically scales to handle event volume
- üîÑ **Reliability**: At-least-once delivery with automatic retries

### Workflows
- ‚ö° **Startup Latency**: ~200ms for first step
- üìä **Step Latency**: ~50-100ms overhead per step
- üîÑ **Reliability**: Automatic state management and retry handling

---

## Cost Considerations

- **Cloud Scheduler**: $0.10 per job per month (3 jobs free)
- **Cloud Tasks**: First 1M operations free, then $0.40 per million
- **Eventarc**: Channel usage charges, see [pricing](https://cloud.google.com/eventarc/pricing)
- **Workflows**: First 5,000 steps free per month, then $0.01 per 1,000 steps

---

## Additional Resources

### Official Documentation

**Cloud Scheduler:**
- [Overview](https://cloud.google.com/scheduler/docs)
- [Quickstart](https://cloud.google.com/scheduler/docs/quickstart)
- [Creating Jobs](https://cloud.google.com/scheduler/docs/creating)
- [Configuring Cron Schedules](https://cloud.google.com/scheduler/docs/configuring/cron-job-schedules)
- [API Reference](https://cloud.google.com/scheduler/docs/reference/rest)
- [Pricing](https://cloud.google.com/scheduler/pricing)

**Cloud Tasks:**
- [Overview](https://cloud.google.com/tasks/docs)
- [Quickstart](https://cloud.google.com/tasks/docs/quickstart)
- [Creating Queues](https://cloud.google.com/tasks/docs/creating-queues)
- [Creating Tasks](https://cloud.google.com/tasks/docs/creating-http-target-tasks)
- [Rate Limits & Retries](https://cloud.google.com/tasks/docs/configuring-queues)
- [API Reference](https://cloud.google.com/tasks/docs/reference/rest)
- [Pricing](https://cloud.google.com/tasks/pricing)

**Eventarc:**
- [Overview](https://cloud.google.com/eventarc/docs)
- [Quickstart](https://cloud.google.com/eventarc/docs/quickstart)
- [Event Sources](https://cloud.google.com/eventarc/docs/event-providers-targets)
- [CloudEvents Specification](https://cloudevents.io/)
- [Creating Triggers](https://cloud.google.com/eventarc/docs/creating-triggers)
- [Filtering Events](https://cloud.google.com/eventarc/docs/path-patterns)
- [API Reference](https://cloud.google.com/eventarc/docs/reference/rest)
- [Pricing](https://cloud.google.com/eventarc/pricing)

**Workflows:**
- [Overview](https://cloud.google.com/workflows/docs)
- [Quickstart](https://cloud.google.com/workflows/docs/quickstart-console)
- [Workflow Syntax](https://cloud.google.com/workflows/docs/reference/syntax)
- [Standard Library Reference](https://cloud.google.com/workflows/docs/reference/stdlib/overview)
- [Connectors](https://cloud.google.com/workflows/docs/reference/googleapis)
- [Error Handling](https://cloud.google.com/workflows/docs/reference/syntax/catching-errors)
- [API Reference](https://cloud.google.com/workflows/docs/reference/rest)
- [Pricing](https://cloud.google.com/workflows/pricing)

### Tutorials & Guides

- [Building Event-Driven Architectures](https://cloud.google.com/eventarc/docs/event-driven-architectures)
- [Orchestrating Multi-Step Workflows](https://cloud.google.com/workflows/docs/tutorials)
- [Managing Background Tasks](https://cloud.google.com/tasks/docs/tutorial-gcf)
- [Scheduling Recurring Jobs](https://cloud.google.com/scheduler/docs/tut-pub-sub)

### Best Practices

- [Cloud Scheduler Best Practices](https://cloud.google.com/scheduler/docs/best-practices)
- [Cloud Tasks Best Practices](https://cloud.google.com/tasks/docs/best-practices)
- [Eventarc Best Practices](https://cloud.google.com/eventarc/docs/best-practices)
- [Workflows Best Practices](https://cloud.google.com/workflows/docs/best-practices)

### Related Services

- [Cloud Functions](https://cloud.google.com/functions/docs) - Execute code in response to events
- [Cloud Run](https://cloud.google.com/run/docs) - Run containers in a fully managed environment
- [Pub/Sub](https://cloud.google.com/pubsub/docs) - Messaging and event streaming
- [Cloud Build](https://cloud.google.com/build/docs) - Continuous integration and delivery

---

## License

MIT License - Feel free to use these demos for learning and development.
